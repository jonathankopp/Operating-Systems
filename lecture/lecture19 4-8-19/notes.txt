+------------+
| Lecture 19 |
+------------+

########### Network Programming #############

socket() creates the endpoint on one side of a connection
connect() attempt to establish a connection with a specified server and port number via TCP

recv()/send() read/write dta across the established connection
read()/write()

close() close socket


while(1)
{
	accept()

	/* either call fork() or pthread_create() here to hand off the new
				established connection to a child process or child thread... */

	CHILD:
		recv()/send()									read/write data across the established connection
		read()/write()
		exit() or pthread_exit()
	
	PARENT:
		close()
}


SERVER TYPES:

(0) Iterative server (typically UDP): accept incoming UDP datagrams on
			a specific port number; or we accept and handle TCP connections one
				after the other (e.g., udp-server.c, tcp-server.c)

			i.e., a single main thread to process client requests

(1) fork()-based server (e.g., tcp-server-fork.c): a child process is
			created for each received TCP client connection

(2) fork()-based server with pre-forked processes(i.e., apache webserver): pre-fork() n processes,
			then as incoming TCP client connection requests come in, assign them
				to child processes (which requires synchronization)

(3) thread-based server: a child thread is created for each received TCP client connection

(4) thread-based server with pre-created threads (i.e, a thread pool): pre-created n threads,
			then as incoming TCP client connection requests come in, assign them
				to child threads (which requires synchronization)

(5) select()-based server: a single process (no multi-threading) that uses
			the select() system call, which enables the process to poll multiple descriptors
				to check for activity on any of them

============================================================================================================

################# Memory Management #####################

Memory Manager:

-- allocate/deallocate memory for processes
		(the OS assigns memory to new/running processes and deallocate memory)

-- protection, i.e., no access to a given process's memory space
		from outside the given process

-- shared memory management (between two or more processes, which could include
			shared libararies, shared memory segments created via shmget(), etc.)

Approaches:
-- Contiguous Memory Allocation
-- Noncontiguous Memory Allocation
-- Virtual Memory

With multiprogramming, multiple options for managing memory

-- early approaches identified PARTITIONS, where a partition is a block
		of CONTIGUOUS MEMORY that can be allocated to a process

Degree of multiprogramming
-- how many processes can be in memory at once?
-- depends on process size, partition size, and the amount of memory
		available overall

A LOGICAL ADDRESS references some location with a given process address space
	-- think of the logical address as an offset from the
			first byte of the process memory (byte 0)

				LOAD x
 LABEL: ...
 				...
				...
				DECR X
				BNE LABEL		; branch up/backwards 48 bytes

	-- RELOCATABLE CODE

	-- when a process is place into physical memory,
			its logical address space is bound to a physical memory space

The OS must map every LOGICAL ADDRESS to a PHYSICAL ADDRESS
-- logical addresses are generated by compilers/assemblers

CONTIGUOUS MEMORY ALLOCATION
-- fit the entire process address space into physical memory
		in one contiguous block

		-- this block has a BASE address (e.g., 14000) or starting point
				in physical memory, as well as a LIMIT (size in bytes)

-- Partitioned memory can be FIXED or DYNAMIC


Fixed Partitioning Scheme
-- Given N partitions of potentially different sizes
-- Each process is allocated to exactly one partiion
-- Each partition is associated with one process or is marked as FREE
-- OS manages a list of free partitions and
		a mapping of used partitions to processes


MEMORY (fixed partitioning scheme):
---------------------------------------
 DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD			Partition 1 (64 memory units)
 DDDDDDDDDDDDDDDDDDDDDDDDDDDDD........
---------------------------------------
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB			Partition 2 (64 memory units)
 BBBBBBBBB............................
---------------------------------------
 CCCCCCCCC............................			Partition 3 (256 memory units)
 .....................................
 .....................................
 .....................................
 .....................................
 .....................................
 .....................................
---------------------------------------

-- if process E arrives and requires 8 memory units, we canot allocate
		a partition for this process because all partitions are in use
			(even though we have enough memory to do so...)

Dynamic Partitioning Scheme
-- the size of a given process will define the size of the allocated partition
-- this is essentially on-demand partitioning

MEMORY (dynamic partitioning scheme):
--------------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB	The set of A's defines one partition
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB	(for process A), the set of B's define
 BBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC another partition, etc.
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC......
 ...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMM............... As time goes by, processes arriving 
 ....................................		and leaving the system cause the memory
 ...FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF		 to become increasingly fragmented
--------------------------------------

If a process arrive and requires more memory than the largest free
	partition, we look to defragmentation.


MEMORY (after defragmentation):
--------------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
 BBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCMMMMMM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMFFFFFFFFFFFFFFFFFFFFFFFF		(close if not exact...)
 FFFFFFFFF...........................
 ....................................
--------------------------------------

We need an algorithm to determine where to place each newly arriving process
-- e.g., process Y arrives and requires 10 memory units

===========================================================================================

FIRST-FIT Algorithm
-- Scan from the "top" of memory until we find
		a free partition that fits process Y

MEMORY (dynamic partitioning scheme);
--------------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB	
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB	
 BBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC......
 ...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMM...............  
 ....................................		
 ...FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF		 
--------------------------------------

NEXT-FIT Algorithm
-- scan from the end of the most recently placed process
		until we find a free partition that fits process Y

MEMORY (dynamic partitioning scheme):
--------------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB	
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB	
 BBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC......
 ...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMM...............  <-- if M was last placed
 ....................................		
 ...FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF		 
--------------------------------------

BEST-FIT Algorithm
-- allocates process Y to the smallest free partition
		that's big enough to fit process Y


MEMORY (dynamic partitioning scheme);
--------------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB	
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB	
 BBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC...... <-- place process Y here (best fit), with
 ...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM				the hope that if a larger process
 MMMMMMMMMMMMMMMMMMMMM...............  				arrives, we can still place it...
 ....................................		
 ...FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF		 
--------------------------------------

WORST-FIT Algorithm
-- allocate process Y to the largest free partition
		that's big enough to fit process Y


MEMORY (dynamic partitioning scheme);
--------------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB	
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB	
 BBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC......
 ...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMMMM............... <-- place process Y here 
 ....................................		
 ...FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF		 
--------------------------------------

		-- does worst-fit give us the benefit of delaying the need for defragmentation?
